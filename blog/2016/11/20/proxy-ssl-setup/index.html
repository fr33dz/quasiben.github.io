<!doctype html>
<meta charset="utf-8">
<head>

<link rel="stylesheet" href="/static/normalize.css">
<link rel="stylesheet" href="/static/skeleton.css">
<link rel="stylesheet" href="/static/style.css">
<link rel="stylesheet" href="/static/pygments.css">

<!-- Mobile Specific Metas
–––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- FONT
–––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

<title>Integration Testing for the Enterprise — quasiben.github.io</title>
</head>
<body>
    <div class="container">

        <div class="row">
            <div class="three columns" style="margin-top: 5%">
                <nav>
                    <h3 id="logo">Benjamin Zaitlen</h3>
                    <ul>
                        <li><a href="/">Index</a></li>
                        
                          <li class="active"><a href="/blog/">Blog</a></li>
                        
                        <li><a target="_blank" href="https://twitter.com/quasiben">Twitter</a>
                        <li><a target="_blank" href="https://github.com/quasiben">Github</a>
                    </ul>
                </nav>
                &nbsp;
            </div>

     <div class="nine columns"  style="margin-top: 5%">
       
  
  <div class="blog-post">
  
    <h2>Integration Testing for the Enterprise</h2>
  
  <p class="meta">
    written by
    
      Benjamin Zaitlen
    
    on 2016-11-20
  </p>
  <p>Building software for enterprises does not just mean more error checking (though it definitely does include that!), it means understanding a bit more about operations and IT.  In this post, I want to tell you about a testing harness I made specifically for testing code paths more commonly used by
enterprise customers.  As a motivating example I am going to test and validate that the package manager <a href="http://conda.pydata.org/">conda</a> can correctly use <a href="http://conda.pydata.org/docs/config.html#configure-conda-for-use-behind-a-proxy-server-proxy-servers">proxies</a> and <a href="http://conda.pydata.org/docs/install/central.html#ssl-verification">self-signed certs</a> the testing proxies and self-signed certs.</p>
<h2>The Problem</h2>
<h3>Proxies</h3>
<p>If your tool/service needs to talk to the internet or generally be accessible
throughout an organization it may need to use a <a href="https://en.wikipedia.org/wiki/Proxy_server">proxy
server</a>.  Proxies often act as
intermediaries between a local intra-net and the global inter-net.  (Late at
night I think of proxies as mild-mannered pixies working at the Ministry of
Regulated
Communication.)  In any case, many enterprise and corporate environments use
proxies and thus your application will need proxy configurations possible.</p>
<h3>Certs</h3>
<p>Your tool may also need to download things occasionally, and that usually means
handling SSL certificates.  SSL certificates are primarily used to encrypt web
traffic -- typically you see them in the URL name prefixed by <code>HTTPS</code>.  In a
follow up post I'll talk more about SSL certificate generation.  Enterprises
and their corporate intra-net, like the web at large, want to encrypt
communication across the various services and tools which operate within it.
Again, that means your tool needs to understand common SSL operations.</p>
<h3>Solution</h3>
<p>The good thing, of course, is that we don't have to build this all from the
ground up -- someone else has already implemented all the technical bits, and
your tools simply need to be configured appropriately.</p>
<p>In the case of <code>conda</code>, for example, handling proxies can be done in one of two
ways: through a <a href="http://conda.pydata.org/docs/config.html#configure-conda-for-use-behind-a-
proxy-server-proxy-servers">setting in the configuration
file</a> or with the common proxy environment variables
<code>https_proxy=proxy_url:port</code> and <code>https_proxy=proxy_url:port</code> for the proxying
of encrypted and unencrypted respectively.  Conda <a href="https://github.com/conda/conda/blob/549f4366d0ac0c2875ee4b3e617de77ce25
c4fc1/conda/connection.py#L74">knows how to handle
proxies</a> because Conda uses
<a href="http://docs.python-requests.org/en/master/user/advanced/#proxies">requests</a>
which knows how to properly handle proxies.</p>
<p>Similarly, Conda can use and validate encrypted communication with SSL certs
with a <a href="http://conda.pydata.org/docs/install/central.html#ssl-verification">configuration
setting</a>;
it <a href="https://github.com/conda/conda/blob/549f4366d0ac0c2875ee4b3e617de77ce25c4fc1/conda/connection.py#L93-L98">passes that info down to requests</a>, and again, <a href="http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-
verification">requests knows how to ssl
verification</a></p>
<p>And if we dig deeper, requests can do it because
<a href="https://github.com/shazow/urllib3">urllib3</a> implemented SSL verification which
in turn is dependent on <a href="https://github.com/pyca/pyopenssl">pyopenssl</a>.  But
now we are out of scope.  The point here is that your new tool probably doesn't
need to worry about all this because someone else did 99% of the work.  What
your tool needs to do is be configurable for these different communication
patterns -- and that brings us to the test.</p>
<h2>Testing!</h2>
<p>We want to test the following:</p>
<ul>
<li>conda install pkg behind a proxy</li>
<li>conda install pkg with a custom ssl cert</li>
</ul>
<p><center><a href="/static/images/Docker+Proxy+Network.png"><img src="/static/images/Docker+Proxy+Network.png" alt="Network Image" width="30%" height="50%"></a></center></p><p>The network above is a good illustration of a proxied network.  We could build
this network on AWS or any other cloud provider.  I've found this fairly time
consuming -- I'm not un-experienced when it comes to AWS, but I have trouble
keeps VPC settings in my head and I will invariably mess up the the port
routing in the security groups.  Still, it's an option, though you do have the
added burden of managing more machines and of course paying for the use.</p>
<p>Instead, we could reproduce this network not with cloud based machines but with
Docker based containers.  This has the advantage of not having to keep track of
more AWS instances and its free of cost.  Using docker also has the added
benefit of being easily integrated into continuous integration tools like
<a href="https://travis-ci.com/">TravisCI</a></p>
<h3>Proxy Testing</h3>
<p>Since Docker 1.9, users have been able to define custom networks for the
containers to exist in.  What this means is that we can build containers in a
network which is unable to communicate with the outside world.  Below is an
example of creating an isolated network named <code>inside</code>:</p>
<pre><code>docker network create inside --internal --driver=bridge \
                   --subnet=192.168.99.0/24 --gateway=192.168.99.1 \
                   --ip-range=192.168.99.128/25
</code></pre>
<p>The key flag here is <code>--internal</code> and it <em>disables</em> communication between the
containers and Docker's bridge to the host.  Another interesting bit to note
about Docker is that existing containers can be <code>connected</code>/<code>disconnected</code> from
existing networks.  So we can build three containers -- <code>proxy</code>, <code>client</code>, and
<code>ssl nginx</code> -- and connect them all to the <code>inside</code> network; then connect the <code>proxy</code> to
Docker's bridge network.  The <code>proxy</code> container will then have access to the
<code>inside</code> network and containers <code>ssl nginx</code> and <code>client</code>, as well as the
outside -- hey that's exactly what a proxy does!</p>
<p>In the <code>proxy</code> container we use the <a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/Dockerfile#L24-
L25">tinyproxy proxy and prepopulate the
config</a> to allow the other containers.  For our proxy test with conda we defined
the environment variables <code>https_proxy</code> and <code>http_proxy</code> to
<a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/start_ssl.sh#L6">install new conda
packages</a></p>
<h3>SSL Testing</h3>
<p>Testing SSL verification with conda takes a bit more setup.  We are going to
need a DNS name, a webserver, some conda packages, and of course a valid cert.
Luckily, <a href="https://jamielinux.com/">Jamie Nguyen</a> has a great <a href="https://jamielinux.com/docs/openssl-certificate-authority/introduc
tion.html">guide on issuing
custom
certificates</a> and I essentially used his method to build a cert for the DNS name
<code>proxy.io</code>.  To <em>fake</em> the DNS lookup I <a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/docker-co
mpose.yml#L23">modified the
/etc/hosts</a> file with the IP of the SSL Nginx container.  Great, so we have
a <em>valid</em> dns name, a valid certificate for that name, we have the conda
packages downloaded using the proxy method, and now we just need to serve them
up.</p>
<p>To serve conda packages, we <a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/start_ssl.sh#L9
-L14">index them and start a server with
python</a>.  Then we use nginx as a reverse proxy to that simple server and redirect
all communication to <code>https</code>: <a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/proxy.io.conf">nginx conf
file</a></p>
<p>With a <a href="https://github.com/quasiben/docker-proxy-ssl/blob/master/condarc">proper condarc
file</a> the
<code>client</code> container can now install conda packages served over SSL on the <code>SSL
nginx</code> container.</p>
<h2>Conclusion</h2>
<p>Testing software for enterprise configurations is possible and painful.  It's
painful because of the variety.  I've found that Docker helps to mitigate that
pain -- it's is flexible enough to handle the variety and easily integrates
into larger testing harnesses. As proof, the full setup of the conda example
describe above is <a href="https://github.com/quasiben/docker-proxy-ssl">hosted on
github</a> complete with
<a href="https://travis-ci.org/quasiben/docker-proxy-ssl">continuous integration with
TravisCI</a></p>

  </div>


     </div>

<!-- JS
================================================== -->
<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76136990-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
